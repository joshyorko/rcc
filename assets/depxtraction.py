#!/bin/env python3

import pip, re, sys

from collections import namedtuple
from importlib import metadata

REJECTED = {'pip', 'pkg_resources', 'pkgutil_resolve_name', 'setuptools', 'wheel'}
CONDA_FORGE = {'robocorp-truststore'}
EMPTY = tuple()

NAMEFORM = re.compile(r'^([a-z0-9](?:[a-z0-9._-]*?[a-z0-9])?)([^a-z0-9._-].*)?$', re.I)
EXTRAFORM = re.compile(r'\bextra\s*=')
NORMALIZE = re.compile(r'[-_.]+')

Metadata = namedtuple('Metadata', 'key name version needs')

HEADER = f'''
# This was generated by `{__file__}` script.
# This is experimental feature for getting `environment.yaml` from installed base.
# It only supports simple `pip` environments, where most dependencies are coming
# from pypi.org. If your desire is to have addtional packages from `conda-forge`
# those must be maintained manually on above `pip:` section.

channels:
- conda-forge
dependencies:
'''.strip()

FOOTER = '''
# NOTE: building above environment might fail, because dependencies are
# collected heuristically. So once you have generated new environment
# configuration, you should actually try to build it using `rcc`.
'''

def normalize(name):
    return NORMALIZE.sub('-', str(name)).lower().strip()
    return re.sub(r'[-_.]+', '-', str(name)).lower().strip()

def list_modules():
    for candidate in metadata.distributions():
        yield candidate

def parselet(text):
    head, *rest = map(str.strip, text.split(';'))
    name, *ignore = map(str.strip, filter(bool, NAMEFORM.match(head).groups()))
    extra = any(map(EXTRAFORM.match, rest))
    return extra, normalize(name)

def environment_yaml(resolved):
    print(HEADER)
    python = sys.version_info
    print(f'- python={python.major}.{python.minor}.{python.micro}')
    print(f'- pip={pip.__version__}')
    for conda in CONDA_FORGE:
        if version := resolved.pop(conda, None):
            print(f'- {conda}={version}')
    if resolved:
        print(f'- pip:')
        for name, version in resolved.items():
            print(f'  - {name}=={version}')
        print(FOOTER)

def process():
    metadata = dict()
    for module in list_modules():
        name = module.metadata.get('name')
        key = normalize(name)
        metadata[key] = Metadata(key, name, module.version, module.requires or EMPTY)

    cyclic = set()
    toplevel = set(metadata.keys())
    tuple(map(toplevel.discard, REJECTED))
    for package, needs in sorted(metadata.items()):
        for entry in needs.needs:
            rejected, name = parselet(entry)
            if (package, name) in cyclic:
                continue
            if not rejected:
                cyclic.add((name, package))
                toplevel.discard(name)

    resolved = dict([metadata[x].name, metadata[x].version] for x in sorted(toplevel))
    environment_yaml(resolved)

if __name__ == '__main__':
    process()
